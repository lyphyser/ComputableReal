import Mathlib.Data.Set.Basic
import Mathlib.Topology.UniformSpace.Cauchy
import Mathlib.Topology.UniformSpace.Completion
import Mathlib.Topology.UniformSpace.UniformEmbedding
import Mathlib.Topology.UniformSpace.Ultra.Completion
import Mathlib.Topology.UniformSpace.Basic
import Mathlib.Order.Filter.Bases.Basic

import ComputableReal.SetInfStream

open Filter UniformSpace Set Function

/-!
  # CauchyStream & Coercions
-/

universe u v w

section

class SetLikeSurjective (Î± Î² : Type*) [SetLike Î± Î²] : Prop where
  surj : Function.Surjective fun a : Î± => (a : Set Î²)

class CauchyFilterCountablyGenerated (Î² : Type*) [UniformSpace Î²] : Prop where
  isCountablyGenerated : âˆ€ f : CauchyFilter Î², f.1.IsCountablyGenerated

variable (Ï„ : Type u) (T : Ï„ â†’ Type v) (Î² : Type u) [UniformSpace Î²]
variable (Î± : Type w) [SetLike Î± Î²]
variable [Inhabited Ï„] [Inhabited (T default)]

/-!
### 1. The Typeclass Definition (Point-free version)
We define `IsUniformShapeBasis` using sets instead of points.
Property: For every target size `U`, there is a tolerance `V` such that
ANY set `S` with diameter less than `V` fits inside a shape `i` with diameter less than `U`.
-/
class IsUniformShapeBasis (Î² : Type*) [UniformSpace Î²] (Î± : Type*) [SetLike Î± Î²] : Prop where
  approx : âˆ€ U âˆˆ uniformity Î², âˆƒ V âˆˆ uniformity Î², âˆ€ S : Set Î², S Ã—Ë¢ S âŠ† V â†’ âˆƒ i : Î±, S âŠ† i âˆ§ (i : Set Î²) Ã—Ë¢ (i : Set Î²) âŠ† U

/-!
### 2. Helper: Filter Generation
Constructs the filter generated by the sequence of shapes.
-/
def filterFromShapeSeq (s : â„• â†’ Î±) : Filter Î² :=
  Filter.generate (Set.range (fun n â†¦ (s n : Set Î²)))

lemma toFilter_ofFn_eq_filterFromShapeSeq (s : â„• â†’ Î±) :
    (InfStream.ofFn (Ï„:=Ï„) (T:=T) s).toFilter = filterFromShapeSeq Î² Î± s := by
  rw [InfStream.toFilter, filterFromShapeSeq]
  simp [InfStream.seq_ofFn]

/-!
### 3. The Theorem
If `Î¹` satisfies the shape basis property, then every Cauchy filter `f`
is finer than a Cauchy filter generated by a sequence of shapes in `Î¹`.
-/
theorem cauchy_filter_generated_by_shape_seq
    [IsUniformShapeBasis Î² Î±]        -- The shapes satisfy the set-based property
    [IsCountablyGenerated (uniformity Î²)]     -- The uniformity is countably generated
    {f : Filter Î²} (hf : Cauchy f) : -- Given a Cauchy filter
    âˆƒ (s : â„• â†’ Î±),                   -- There exists a sequence of shapes
      (f â‰¤ filterFromShapeSeq Î² Î± s) âˆ§
      Cauchy (filterFromShapeSeq Î² Î± s) := by

  -- 1. Extract the countable basis of entourages {U_n}
  rcases UniformSpace.has_seq_basis Î² with âŸ¨U, hU_basisâŸ©

  -- 2. Use the Typeclass `approx` to get tolerances V_n for each U_n
  have h_approx : âˆ€ n, âˆƒ V âˆˆ uniformity Î², âˆ€ S : Set Î², S Ã—Ë¢ S âŠ† V â†’ âˆƒ i : Î±, S âŠ† i âˆ§ (i : Set Î²) Ã—Ë¢ (i : Set Î²) âŠ† U n :=
    fun n â†¦ IsUniformShapeBasis.approx (U n) (hU_basis.1.mem n)
  choose V hV_mem h_fit using h_approx

  -- 3. Since f is Cauchy, for every V_n, f contains a set F_n small of order V_n
  have h_cauchy_sets : âˆ€ n, âˆƒ F âˆˆ f, F Ã—Ë¢ F âŠ† V n :=
    fun n â†¦ Filter.mem_prod_self_iff.mp (hf.right (hV_mem n))
  choose F hF_in_f hF_small using h_cauchy_sets

  -- 4. DIRECTLY construct the sequence of shapes s_n.
  --    We apply h_fit to the set F_n.
  have h_shape_exists : âˆ€ n, âˆƒ i : Î±, (F n âŠ† i) âˆ§ ((i : Set Î²) Ã—Ë¢ (i : Set Î²) âŠ† U n) :=
    fun n â†¦ h_fit n (F n) (hF_small n)
  choose s hs_large hs_small using h_shape_exists

  use s
  constructor
  Â· -- Proof: The generated filter is coarser than f (f â‰¤ generate s)
    -- We show that every shape set (s n) is in f.
    -- f â‰¤ generate s iff generate s âŠ† f. (Wait, â‰¤ means finer, f finer than generate s).
    -- Wait. If f â‰¤ generate s, then f is finer.
    -- generate s contains s.
    -- If f is finer, f contains s.
    -- We know s n contains F n, and F n âˆˆ f.
    -- So s n âˆˆ f.
    -- So range s âŠ† f.sets.
    -- generate s is coarsest containing range s.
    -- So generate s âŠ† f.
    -- So f â‰¤ generate s.
    -- Correct.
    rw [filterFromShapeSeq]
    apply le_generate_iff.mpr
    rw [range_subset_iff]
    intro n
    exact mem_of_superset (hF_in_f n) (hs_large n)

  Â· -- Proof: The generated filter is Cauchy
    refine âŸ¨?_, ?_âŸ©

    -- A. NeBot (Properness)
    -- Since s_n âˆˆ f (proved above) and f is proper, s_n is non-empty.
    rw [filterFromShapeSeq]
    apply hf.1.mono
    apply le_generate_iff.mpr
    rw [range_subset_iff]
    intro n
    exact mem_of_superset (hF_in_f n) (hs_large n)

    -- B. Cauchy Condition
    -- For any entourage E, we must find a set in the generated filter small of order E.
    intro E hE
    -- Find a U_k contained in E (using the basis property)
    rcases hU_basis.1.mem_iff.mp hE with âŸ¨k, hUk_sub_EâŸ©

    -- The set (s k) is in the generated filter and is U_k-small.
    rw [Filter.mem_prod_self_iff]
    exists s k
    constructor
    Â· rw [filterFromShapeSeq]
      exact Filter.mem_generate_of_mem (mem_range_self k)
    Â· have h_sub : (s k : Set Î²) Ã—Ë¢ (s k : Set Î²) âŠ† U k := hs_small k
      refine Subset.trans h_sub hUk_sub_E


/--
  `CauchyStream` is the bundled subtype of streams that generate Cauchy filters.
-/
def CauchyStream :=
  { s : InfStream Ï„ T Î± // Cauchy s.toFilter }

local instance : UniformSpace { f : Filter Î² // Cauchy f } :=
  (inferInstance : UniformSpace (CauchyFilter Î²))

/--
  Coercion: a `CauchyStream` can be used where a `CauchyFilter` is expected.
-/
instance : CoeTC (CauchyStream Ï„ T Î² Î±) (CauchyFilter Î²) where
  coe s := âŸ¨s.1.toFilter, s.2âŸ©

/-!
  ### Transporting instances from `CauchyFilter`
-/

instance : UniformSpace (CauchyStream Ï„ T Î² Î±) :=
  UniformSpace.comap (fun s => (s : CauchyFilter Î²)) inferInstance

private def isUniformInducing_coe :
    IsUniformInducing (fun s : CauchyStream Ï„ T Î² Î± => (s : CauchyFilter Î²)) :=
  (isUniformInducing_iff_uniformSpace).mpr rfl

instance [IsUltraUniformity (CauchyFilter Î²)] : IsUltraUniformity (CauchyStream Ï„ T Î² Î±) := by
  letI : IsUltraUniformity { f : Filter Î² // Cauchy f } :=
    (inferInstance : IsUltraUniformity (CauchyFilter Î²))
  have h_inducing :
      IsUniformInducing (fun s : CauchyStream Ï„ T Î² Î± => (s : CauchyFilter Î²)) :=
    isUniformInducing_coe Ï„ T Î² Î±
  exact h_inducing.isUltraUniformity

section StrongAssumptions

variable [SetLikeSurjective Î± Î²] [CauchyFilterCountablyGenerated Î²]

theorem exists_stream_of_cauchy (f : CauchyFilter Î²) :
    âˆƒ s : InfStream Ï„ T Î±, s.toFilter = f.1 := by
  classical
  haveI := CauchyFilterCountablyGenerated.isCountablyGenerated (Î²:=Î²) f
  obtain âŸ¨x, hxanti, hxmemâŸ© := f.1.exists_antitone_seq
  choose a ha using (fun n => (SetLikeSurjective.surj (Î±:=Î±) (Î²:=Î²)) (x n))
  let s : InfStream Ï„ T Î± := InfStream.ofFn a
  refine âŸ¨s, ?_âŸ©
  apply Filter.ext
  intro U
  have hxInf :
      (â¨… n, ð“Ÿ (x n)).HasAntitoneBasis x :=
    Filter.HasAntitoneBasis.iInf_principal hxanti
  have hxInf_mem :
      U âˆˆ â¨… n, ð“Ÿ (x n) â†” âˆƒ i, x i âŠ† U := by
    simpa using (hxInf.1.mem_iff : U âˆˆ â¨… n, ð“Ÿ (x n) â†” âˆƒ i, True âˆ§ x i âŠ† U)
  have hxmem' : U âˆˆ f.1 â†” âˆƒ i, x i âŠ† U := by
    simpa using (hxmem : U âˆˆ f.1 â†” âˆƒ i, x i âŠ† U)
  have hfilter : s.toFilter = â¨… n, ð“Ÿ (x n) := by
    rw [InfStream.toFilter]
    dsimp [s]
    simp [InfStream.seq_ofFn, ha]
    apply le_antisymm
    Â· -- generate â‰¤ â¨…
      -- generate is finer than â¨… (so â¨… âŠ† generate)
      intro V hV
      rw [hxInf.mem_iff] at hV
      rcases hV with âŸ¨k, hkâŸ©
      apply mem_of_superset (Filter.mem_generate_of_mem (mem_range_self k)) hk
    Â· -- â¨… â‰¤ generate
      -- â¨… is finer than generate (so generate âŠ† â¨…)
      apply le_generate_iff.mpr
      rw [range_subset_iff]
      intro n
      -- x n is in â¨… i, ð“Ÿ (x i)
      exact hxInf.mem_iff.mpr âŸ¨n, subset_refl (x n)âŸ©
  simpa [hfilter] using (hxInf_mem.trans hxmem'.symm)

noncomputable def choiceStream (f : CauchyFilter Î²) : CauchyStream Ï„ T Î² Î± :=
  âŸ¨Classical.choose (exists_stream_of_cauchy (Ï„:=Ï„) (T:=T) (Î²:=Î²) (Î±:=Î±) f),
    by
      simpa [Classical.choose_spec (exists_stream_of_cauchy (Ï„:=Ï„) (T:=T) (Î²:=Î²) (Î±:=Î±) f)]
        using f.2âŸ©

theorem choiceStream_coe (f : CauchyFilter Î²) :
    (choiceStream (Ï„:=Ï„) (T:=T) (Î²:=Î²) (Î±:=Î±) f : CauchyFilter Î²) = f := by
  apply Subtype.ext
  simp [choiceStream,
    Classical.choose_spec (exists_stream_of_cauchy (Ï„:=Ï„) (T:=T) (Î²:=Î²) (Î±:=Î±) f)]

theorem leftInverse_coe :
    Function.LeftInverse (fun s : CauchyStream Ï„ T Î² Î± => (s : CauchyFilter Î²))
      (choiceStream (Ï„:=Ï„) (T:=T) (Î²:=Î²) (Î±:=Î±)) :=
  choiceStream_coe (Ï„:=Ï„) (T:=T) (Î²:=Î²) (Î±:=Î±)

instance : CompleteSpace (CauchyStream Ï„ T Î² Î±) := by
  have h_inducing :
      IsUniformInducing (fun s : CauchyStream Ï„ T Î² Î± => (s : CauchyFilter Î²)) :=
    isUniformInducing_coe Ï„ T Î² Î±
  have hsurj :
      Function.Surjective (fun s : CauchyStream Ï„ T Î² Î± => (s : CauchyFilter Î²)) :=
    (Function.LeftInverse.surjective (leftInverse_coe (Ï„:=Ï„) (T:=T) (Î²:=Î²) (Î±:=Î±)))
  have h_complete :
      CompleteSpace (CauchyFilter Î²) :=
    (inferInstance : CompleteSpace (CauchyFilter Î²))
  exact
    (IsUniformInducing.completeSpace_congr h_inducing hsurj).mpr h_complete

end StrongAssumptions

section NewConstruction

variable [IsUniformShapeBasis Î² Î±] [IsCountablyGenerated (uniformity Î²)]

noncomputable def cauchyStreamFromFilter (f : CauchyFilter Î²) : CauchyStream Ï„ T Î² Î± :=
  let s := Classical.choose (cauchy_filter_generated_by_shape_seq Î² Î± f.2)
  âŸ¨InfStream.ofFn s, by
    rw [toFilter_ofFn_eq_filterFromShapeSeq]
    exact (Classical.choose_spec (cauchy_filter_generated_by_shape_seq Î² Î± f.2)).2âŸ©

theorem cauchyStreamFromFilter_le (f : CauchyFilter Î²) :
    f.1 â‰¤ (cauchyStreamFromFilter (Ï„:=Ï„) (T:=T) (Î²:=Î²) (Î±:=Î±) f).1.toFilter := by
  dsimp [cauchyStreamFromFilter]
  rw [toFilter_ofFn_eq_filterFromShapeSeq]
  exact (Classical.choose_spec (cauchy_filter_generated_by_shape_seq Î² Î± f.2)).1

end NewConstruction

end
