import Mathlib.Data.Set.Basic
import Mathlib.Topology.UniformSpace.Cauchy
import Mathlib.Topology.UniformSpace.Completion
import Mathlib.Topology.UniformSpace.UniformEmbedding
import Mathlib.Topology.UniformSpace.Ultra.Completion
import Mathlib.Topology.UniformSpace.Basic
import Mathlib.Order.Filter.Bases.Basic

import ComputableReal.SetInfStream

open Filter UniformSpace Set Function

/-!
  # CauchyStream & Coercions
-/

universe u v w

section

variable (τ : Type u) (T : τ → Type v) (β : Type u) [UniformSpace β]
variable (α : Type w) [SetLike α β]
variable [Inhabited τ] [Inhabited (T default)]

/-!
### 1. The Typeclass Definition (Point-free version)
We define `IsUniformShapeBasis` using sets instead of points.
Property: For every target size `U`, there is a tolerance `V` such that
ANY set `S` with diameter less than `V` fits inside a shape `i` with diameter less than `U`.
-/
class IsUniformShapeBasis (β : Type*) [UniformSpace β] (α : Type*) [SetLike α β] : Prop where
  approx : ∀ U ∈ uniformity β, ∃ V ∈ uniformity β, ∀ S : Set β, S ×ˢ S ⊆ V → ∃ i : α, S ⊆ i ∧ (i : Set β) ×ˢ (i : Set β) ⊆ U

/-!
### 3. The Theorem
If `ι` satisfies the shape basis property, then every Cauchy filter `f`
is finer than a Cauchy filter generated by a sequence of shapes in `ι`.
-/
theorem cauchy_filter_generated_by_shape_seq
    [IsUniformShapeBasis β α]        -- The shapes satisfy the set-based property
    [IsCountablyGenerated (uniformity β)]     -- The uniformity is countably generated
    {f : Filter β} (hf : Cauchy f) : -- Given a Cauchy filter
    ∃ (s : ℕ → α),                   -- There exists a sequence of shapes
      (f ≤ InfStream.filterFromShapeSeq s) ∧
      Cauchy (InfStream.filterFromShapeSeq s) := by

  -- 1. Extract the countable basis of entourages {U_n}
  rcases UniformSpace.has_seq_basis β with ⟨U, hU_basis⟩

  -- 2. Use the Typeclass `approx` to get tolerances V_n for each U_n
  have h_approx : ∀ n, ∃ V ∈ uniformity β, ∀ S : Set β, S ×ˢ S ⊆ V → ∃ i : α, S ⊆ i ∧ (i : Set β) ×ˢ (i : Set β) ⊆ U n :=
    fun n ↦ IsUniformShapeBasis.approx (U n) (hU_basis.1.mem n)
  choose V hV_mem h_fit using h_approx

  -- 3. Since f is Cauchy, for every V_n, f contains a set F_n small of order V_n
  have h_cauchy_sets : ∀ n, ∃ F ∈ f, F ×ˢ F ⊆ V n :=
    fun n ↦ Filter.mem_prod_self_iff.mp (hf.right (hV_mem n))
  choose F hF_in_f hF_small using h_cauchy_sets

  -- 4. DIRECTLY construct the sequence of shapes s_n.
  --    We apply h_fit to the set F_n.
  have h_shape_exists : ∀ n, ∃ i : α, (F n ⊆ i) ∧ ((i : Set β) ×ˢ (i : Set β) ⊆ U n) :=
    fun n ↦ h_fit n (F n) (hF_small n)
  choose s hs_large hs_small using h_shape_exists

  use s
  constructor
  · -- Proof: The generated filter is coarser than f (f ≤ generate s)
    -- We show that every shape set (s n) is in f.
    -- f ≤ generate s iff generate s ⊆ f. (Wait, ≤ means finer, f finer than generate s).
    -- Wait. If f ≤ generate s, then f is finer.
    -- generate s contains s.
    -- If f is finer, f contains s.
    -- We know s n contains F n, and F n ∈ f.
    -- So s n ∈ f.
    -- So range s ⊆ f.sets.
    -- generate s is coarsest containing range s.
    -- So generate s ⊆ f.
    -- So f ≤ generate s.
    -- Correct.
    rw [InfStream.filterFromShapeSeq]
    apply le_generate_iff.mpr
    rw [range_subset_iff]
    intro n
    exact mem_of_superset (hF_in_f n) (hs_large n)

  · -- Proof: The generated filter is Cauchy
    refine ⟨?_, ?_⟩

    -- A. NeBot (Properness)
    -- Since s_n ∈ f (proved above) and f is proper, s_n is non-empty.
    rw [InfStream.filterFromShapeSeq]
    apply hf.1.mono
    apply le_generate_iff.mpr
    rw [range_subset_iff]
    intro n
    exact mem_of_superset (hF_in_f n) (hs_large n)

    -- B. Cauchy Condition
    -- For any entourage E, we must find a set in the generated filter small of order E.
    intro E hE
    -- Find a U_k contained in E (using the basis property)
    rcases hU_basis.1.mem_iff.mp hE with ⟨k, hUk_sub_E⟩

    -- The set (s k) is in the generated filter and is U_k-small.
    rw [Filter.mem_prod_self_iff]
    exists s k
    constructor
    · rw [InfStream.filterFromShapeSeq]
      exact Filter.mem_generate_of_mem (mem_range_self k)
    · have h_sub : (s k : Set β) ×ˢ (s k : Set β) ⊆ U k := hs_small k
      refine Subset.trans h_sub hUk_sub_E


/--
  `CauchyStream` is the bundled subtype of streams that generate Cauchy filters.
-/
def CauchyStream :=
  { s : InfStream τ T α // Cauchy s.toFilter }

local instance : UniformSpace { f : Filter β // Cauchy f } :=
  (inferInstance : UniformSpace (CauchyFilter β))

/--
  Coercion: a `CauchyStream` can be used where a `CauchyFilter` is expected.
-/
instance : CoeTC (CauchyStream τ T β α) (CauchyFilter β) where
  coe s := ⟨s.1.toFilter, s.2⟩

/-!
  ### Transporting instances from `CauchyFilter`
-/

instance : UniformSpace (CauchyStream τ T β α) :=
  UniformSpace.comap (fun s => (s : CauchyFilter β)) inferInstance

private def isUniformInducing_coe :
    IsUniformInducing (fun s : CauchyStream τ T β α => (s : CauchyFilter β)) :=
  (isUniformInducing_iff_uniformSpace).mpr rfl

instance [IsUltraUniformity (CauchyFilter β)] : IsUltraUniformity (CauchyStream τ T β α) := by
  letI : IsUltraUniformity { f : Filter β // Cauchy f } :=
    (inferInstance : IsUltraUniformity (CauchyFilter β))
  have h_inducing :
      IsUniformInducing (fun s : CauchyStream τ T β α => (s : CauchyFilter β)) :=
    isUniformInducing_coe τ T β α
  exact h_inducing.isUltraUniformity

section Construction

variable [IsUniformShapeBasis β α] [IsCountablyGenerated (uniformity β)]

noncomputable def cauchyStreamFromFilter (f : CauchyFilter β) : CauchyStream τ T β α :=
  let s := Classical.choose (cauchy_filter_generated_by_shape_seq β α f.2)
  ⟨InfStream.ofFn s, by
    rw [InfStream.toFilter_ofFn_eq_filterFromShapeSeq]
    exact (Classical.choose_spec (cauchy_filter_generated_by_shape_seq β α f.2)).2⟩

theorem cauchyStreamFromFilter_le (f : CauchyFilter β) :
    f.1 ≤ (cauchyStreamFromFilter (τ:=τ) (T:=T) (β:=β) (α:=α) f).1.toFilter := by
  dsimp [cauchyStreamFromFilter]
  rw [InfStream.toFilter_ofFn_eq_filterFromShapeSeq]
  exact (Classical.choose_spec (cauchy_filter_generated_by_shape_seq β α f.2)).1

end Construction

end
